/// <reference path='./element.ts' />
/// <reference path='./dom.ts' />

/**
 * @namespace svjs.ui
 */
namespace svjs.ui {

/*
 Panel -> Item
       -> Panel
          +-> Item
            +-> Button
            +-> Slider
            +-> Other (?)
          +-> Item
          +-> Panel
       -> Item
 */

interface PanelCallback {
    (value?: number | string): void;
}

/**
 * Any item that is displayed within a pop-up panel.  Items are laid out
 * vertically and each item can take up an unspecifed amount of vertical space.
 * The width of each element is the same.
 *
 * Internally, each item is its own `<li>` tag in an unordered list.  The
 * main class name must be specified since this is used to style the element.
 * Each element can display an optional separator to provided a visual boundary
 * between neighbouring elements.
 *
 * @memberof svjs.ui
 * @implements svjs.ui.UiElement
 */
abstract class PanelItem implements UiElement {

    /**
     * @param {string} name - class name
     * @param {string=} id - optional ID attribute
     */
    public constructor(name: string, id?: string) {
        this.item_ = dom.Generate('li');
        this.item_.AddClass(name);
        if (id) {
            this.item_.ID = id;
        }
    }

    /**
     * Adds an optional separator to the panel item.
     * @param {boolean} add - enable/disable the separator
     */
    public AddSeparator(add: boolean) {
        if (add) {
            this.item_.AddClass('svjs-panel-item-add-separator');
        } else {
            this.item_.RemoveClass('svjs-panel-item-add-separator');
        }
    }

    /**
     * @callback svjs.ui.PanelItem~PanelCallback
     * @param {string|number=} value - the value being passed to the receiver
     */

    /**
     * Attach a callback used to respond to events generated by this item.
     * The callback may also return some value to the receiver, however this
     * depends on the particular item.
     * @param {svjs.ui.PanelItem~PanelCallback} cb - event handler callback
     */
    public abstract AddCallback(cb: PanelCallback);

    // -- interface methods ------------------------------------------------ //

    public GetElement(): dom.Li {
        return this.item_;
    }

    // -- protected members ------------------------------------------------ //
    protected item_: dom.Li;
}

enum ButtonDecorator {
    None,
    LeftArrow,
    RightArrow
}

/**
 * The simplest possible panel option.  It supports some visual decorators that
 * can be used to indicate what the item does.  However, it is mostly just some
 * text that changes colour on a mouse-over event.
 * @memberof svjs.ui
 * @extends PanelItem
 */
export class PanelButton extends PanelItem {

    /**
     * @param {string} label - text displayed by the button
     */
    public constructor(label: string, id?: string) {
        super('svjs-panel-item-button', id);
        this.decorator_ = ButtonDecorator.None;
        this.label_ = label;
        this.UpdateElement_();
    }

    public ShowLeftArrow(show: boolean) {
        if (show) {
            this.decorator_ = ButtonDecorator.LeftArrow;
        } else {
            this.decorator_ = ButtonDecorator.None;
        }
        this.UpdateElement_();
    }

    public ShowRightArrow(show: boolean) {
        if (show) {
            this.decorator_ = ButtonDecorator.RightArrow;
        } else {
            this.decorator_ = ButtonDecorator.None;
        }
        this.UpdateElement_();
    }

    // -- superclass overrides --------------------------------------------- //

    public AddCallback(cb: () => void) {
        this.item_.Element.addEventListener('click', cb);
    }

    // -- private members -------------------------------------------------- //
    private UpdateElement_() {
        this.item_.RemoveAllChildren();
        if (this.decorator_ === ButtonDecorator.None) {
            this.item_.Element.textContent = this.label_;
        } else {
            let text = dom.Generate('span');
            text.Element.textContent = this.label_;

            let arrow = dom.Generate('span');
            if (this.decorator_ === ButtonDecorator.LeftArrow) {
                arrow.Element.textContent = '\u2039'; // the '‹' character
                text.Element.style.cssFloat = 'right';
                text.Element.style.marginLeft = '0.5em';

                this.item_.Attach(arrow);
                this.item_.Attach(text);
            } else if (this.decorator_ === ButtonDecorator.RightArrow) {
                arrow.Element.textContent = '\u203A'; // the '›' character
                arrow.Element.style.cssFloat = 'right';
                text.Element.style.marginRight = '0.5em';

                this.item_.Attach(text);
                this.item_.Attach(arrow);
            }
        }
    }

    private decorator_: ButtonDecorator;
    private label_: string;
}

interface PanelSliderRange {
    min: number;
    max: number;
}

/**
 * A panel element consisting of a range `<input>` (i.e. slider) and an
 * associated label.
 * @memberof svjs.ui
 * @extends PanelItem
 */
export class PanelSlider extends PanelItem {
    public constructor(label: string, range: PanelSliderRange, id?: string) {
        super('svjs-panel-item-slider', id);

        let lbl_slider = dom.Generate('span');
        lbl_slider.Element.textContent = label;

        this.slider_ = dom.Generate('input');
        this.slider_.Element.type = 'range';
        this.slider_.Element.min = range.min.toString();
        this.slider_.Element.max = range.max.toString();

        this.item_.Attach(lbl_slider);
        this.item_.Attach(this.slider_);
    }

    /**
     * The slider's current value.
     * @member {number}
     */
    get Value(): number {
        return this.slider_.Element.valueAsNumber;
    }

    set Value(value: number) {
        this.slider_.Element.valueAsNumber = value;
    }

    // -- superclass overrides --------------------------------------------- //

    public AddCallback(cb: PanelCallback) {
        this.slider_.Element.addEventListener('input', () => {
            cb(this.Value);
        });
    }

    // -- private members -------------------------------------------------- //
    private slider_: dom.Input;
}

export class PanelText extends PanelItem {

    public constructor(html: string, id?: string) {
        super('svjs-panel-item-text', id);
        this.content_ = dom.Generate('div');
        this.content_.Element.innerHTML = html;
        this.item_.Attach(this.content_);
    }

    public AddCallback(cb: PanelCallback) {
        // no-op
    }

    private content_: dom.Div;
}

interface SubpanelList {
    [id: string]: Panel;
}

/**
 * A pop-up panel is a collection of elements within a top-level panel.  A
 * panel is composed of one or more #{svjs.ui.PanelItem}'s that are displayed
 * as a vertical list.  Panels can also be nested to create a hierarchical
 * menu structure.
 * @memberof svjs.ui
 * @implements UiElement
 */
export class Panel implements UiElement {

    private static Root_: Panel = null;

    /**
     * @param {string} id - panel's ID attribute
     * @param {string=} name - optional, user-friendly name
     */
    public constructor(id: string, name?: string) {
        this.entries_ = [];
        this.subpanels_ = {};
        this.parent_ = null;

        this.panel_ = dom.Generate('div');
        this.panel_.Attach(dom.Generate<HTMLUListElement>('ul'));
        this.panel_.AddClass('svjs-panel');
        this.panel_.ID = id;
        this.name_ = name || id;    // use the ID if name isn't provided
    }

    /**
     * Add an item to the panel.  The order in which the items are added will
     * effect the order in which they appear.  Panels can also be added to
     * other panels as "subpanels".  This is represented as a
     * #{svjs.ui.PanelButton} with a right-arrow decorator and menu separator.
     * Subpanels will also have an extra button at the top providing a way to
     * return to the parent panel.
     * @param {svjs.ui.PanelItem | svjs.ui.Panel} item - item to add
     * @return {svjs.ui.Panel} - a reference to `this` object to allow this
     *      method to be chained
     */
    public AddItem(item: PanelItem | Panel): Panel {
        if (item instanceof Panel) {
            item.SetParent(this);
            this.subpanels_[item.ID] = item;
            this.AddItem(this.SubpanelButton_(item));
        } else {
            this.entries_.push(item);
            this.GetList_().Attach(item.GetElement());
        }

        return this;
    }

    /**
     * Show/hide the current panel by toggelling its visibility.  This is
     * accomplished via a `svjs-panel-hidden` class that changes its CSS
     * "display" property.  This will normally be called on the top-level panel
     * and broadcast the state-change to all subpanels.
     * @param {boolean} show - show/hide the panel
     */
    public Show(show: boolean) {
        if (show) {
            this.panel_.RemoveClass('svjs-panel-hidden');

            // Reset the menu so that when it becomes visible, it shows the
            // top-level or "root" panel.
            if (Panel.Root_) {
                this.panel_.Replace(Panel.Root_.GetElement());
            } else {
                Panel.Root_ = this;
            }
        } else {
            this.panel_.AddClass('svjs-panel-hidden');
        }

        // Descend down the navigation tree, showing/hiding all menus.
        for (let id in this.subpanels_) {
            if (this.subpanels_.hasOwnProperty(id)) {
                this.subpanels_[id].Show(show);
            }
        }
    }

    /**
     * The panel's unique ID.
     * @member {string}
     */
    get ID(): string {
        return this.panel_.ID;
    }

    /**
     * The panel's user-friendly name.  This will be same as the ID if no name
     * was provided.
     * @member {string}
     */
    get Name(): string {
        return this.name_;
    }

    /**
     * The parent to the current panel.  This will be `null` for any top-level
     * panels.
     * @member {svjs.ui.Panel}
     */
    get Parent(): Panel {
        return this.parent_;
    }

    /**
     * Indicates if the *root* panel is currently visible.  This is because the
     * visibility of any nested panels is dependent on the top-level panel.
     */
    get Visible(): boolean {
        let root = this.FindTopLevelPanel();
        return !root.panel_.Element.classList.contains('svjs-panel-hidden');
    }

    // -- interface methods ------------------------------------------------ //

    public GetElement(): dom.Div {
        return this.panel_;
    }

    // -- protected members ------------------------------------------------ //

    protected SetParent(parent: Panel) {
        this.parent_ = parent;
        if (this.entries_.length > 0) {
            this.entries_[0].AddSeparator(true);
        }

        let go_back = new PanelButton('Back');
        go_back.ShowLeftArrow(true);
        go_back.AddCallback(() => {
            this.panel_.Replace(this.parent_.GetElement());
        });

        this.entries_.unshift(go_back);
        this.GetList_().AttachAsFirst(go_back.GetElement());
    }

    protected FindTopLevelPanel(): Panel {
        let root: Panel = this;
        while (root.parent_) {
            root = root.parent_;
        }
        return root;
    }

    // -- private members -------------------------------------------------- //

    private GetList_(): dom.Item<HTMLUListElement> {
        return new dom.Item(
            <HTMLUListElement>this.panel_.Element.firstElementChild);
    }

    private SubpanelButton_(item: Panel): PanelButton {
        const button = new PanelButton(item.Name);
        button.ShowRightArrow(true);
        button.AddSeparator(this.entries_.length > 0);
        button.AddCallback(() => {
            this.panel_.Replace(item.GetElement());
        });

        return button;
    }

    private panel_: dom.Div;
    private entries_: PanelItem[];

    private name_: string;
    private parent_: Panel;
    private subpanels_: SubpanelList;
}

}
